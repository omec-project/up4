/*
 SPDX-License-Identifier: LicenseRef-ONF-Member-Only-1.0
 SPDX-FileCopyrightText: 2020-present Open Networking Foundation <info@opennetworking.org>
 */
package org.omecproject.up4;

import org.onlab.packet.Ip4Address;
import org.onlab.util.ImmutableByteSequence;

import static com.google.common.base.Preconditions.checkArgument;

/**
 * A single Packet Detection Rule (PDR), an entity described in the 3GPP specifications (although that does not mean
 * that this class is 3GPP compliant). An instance of this class will be generated by a logical switch write request
 * to the database-style PDR P4 table, and the resulting instance should contain all the information needed to
 * reproduce that logical switch PDR in the event of a client read request. The instance should also contain sufficient
 * information (or expose the means to retrieve such information) to generate the corresponding
 * fabric.p4 dataplane forwarding state that implements the PDR.
 */
public final class PacketDetectionRule {
    // Match keys
    private final Ip4Address ueAddr;  // The UE IP address that this PDR matches on
    private final ImmutableByteSequence teid;  // The Tunnel Endpoint ID that this PDR matches on (if PDR is uplink)
    private final Ip4Address tunnelDst;  // The tunnel destination address that this PDR matches on (if PDR is uplink)
    // Action parameters
    private final ImmutableByteSequence sessionId;  // The ID of the PFCP session that created this PDR
    private final Integer ctrId;  // Counter ID unique to this PDR
    private final Integer localFarId;  // The PFCP session-local ID of the FAR that should apply after this PDR hits
    private final Type type; // Is the PDR Uplink, Downlink, etc.
    private Integer globalFarId; // The non-session-local ID of the FAR that should apply to packets if this PDR hits

    private PacketDetectionRule(ImmutableByteSequence sessionId, Integer ctrId, Integer localFarId, Ip4Address ueAddr,
                                ImmutableByteSequence teid, Ip4Address tunnelDst, Integer globalFarId, Type type) {
        this.ueAddr = ueAddr;
        this.teid = teid;
        this.tunnelDst = tunnelDst;
        this.sessionId = sessionId;
        this.ctrId = ctrId;
        this.localFarId = localFarId;
        this.type = type;
        this.globalFarId = globalFarId;
    }

    public static Builder builder() {
        return new Builder();
    }

    @Override
    public String toString() {
        String matchKeys;
        String directionString;
        if (isUplink()) {
            directionString = "Uplink";
            matchKeys = String.format("TunnelDst:%s,TEID:%s",
                    tunnelDst.toString(), teid.toString());
        } else {
            directionString = "Downlink";
            matchKeys = String.format("UE:%s", ueAddr.toString());
        }
        String actionParams = "";
        if (hasActionParameters()) {
            String globalIdStr = globalFarId == null ? "None" : globalFarId.toString();
            actionParams = String.format("SEID:%s,FAR:%d,FAR-GID:%s,CtrIdx:%d",
                    sessionId.toString(), localFarId, globalIdStr, ctrId);
        }

        return String.format("%s-PDR{ Keys:(%s) -> Params (%s) }", directionString, matchKeys, actionParams);
    }

    /**
     * Instances created as a result of DELETE write requests will not have action parameters, only match keys.
     * This method should be used to avoid null pointer exceptions in those instances.
     *
     * @return true if this instance has PDR action parameters, false otherwise.
     */
    public boolean hasActionParameters() {
        return type == Type.UPLINK || type == Type.DOWNLINK;
    }

    /**
     * True if this PDR matches on packets travelling in the uplink direction, and false otherwise.
     *
     * @return true if the PDR matches only uplink packets
     */
    public boolean isUplink() {
        return type == Type.UPLINK || type == Type.UPLINK_KEYS_ONLY;
    }

    /**
     * True if this PDR matches on packets travelling in the downlink direction, and false otherwise.
     *
     * @return true if the PDR matches only downlink packets
     */
    public boolean isDownlink() {
        return type == Type.DOWNLINK || type == Type.DOWNLINK_KEYS_ONLY;
    }

    /**
     * Check whether a global FAR ID has been assigned, which is necessary for an entry to be written
     * to the fabric.p4 pipeline.
     *
     * @return true if a global FAR ID has been assigned
     */
    public boolean hasGlobalFarId() {
        return this.globalFarId != null;
    }

    /**
     * Set the globally unique identifier of the FAR that should apply to packets that match this PDR.
     *
     * @return globally unique FAR ID
     */
    public int getGlobalFarId() {
        return this.globalFarId;
    }

    /**
     * Get the globally unique identifier of the FAR that should apply to packets that match this PDR.
     *
     * @param globalFarId globally unique FAR ID
     */
    public void setGlobalFarId(int globalFarId) {
        this.globalFarId = globalFarId;
    }

    /**
     * Get the ID of the PFCP session that produced this PDR.
     *
     * @return PFCP session ID
     */
    public ImmutableByteSequence sessionId() {
        return sessionId;
    }

    /**
     * Get the UE IP address that this PDR matches on.
     *
     * @return UE IP address
     */
    public Ip4Address ueAddress() {
        return ueAddr;
    }

    /**
     * Get the identifier of the GTP tunnel that this PDR matches on.
     *
     * @return GTP tunnel ID
     */
    public ImmutableByteSequence teid() {
        return teid;
    }

    /**
     * Get the destination IP of the GTP tunnel that this PDR matches on.
     *
     * @return GTP tunnel destination IP
     */
    public Ip4Address tunnelDest() {
        return tunnelDst;
    }

    /**
     * Get the dataplane PDR counter cell ID that this PDR is assigned.
     *
     * @return PDR counter cell ID
     */
    public int counterId() {
        return ctrId;
    }

    /**
     * Get the PFCP session-local ID of the far that should apply to packets that this PDR matches.
     *
     * @return PFCP session-local FAR ID
     */
    public int localFarId() {
        return localFarId;
    }

    public enum Type {
        /**
         * Uplink PDRs match on packets travelling in the uplink direction. These packets will have a GTP tunnel.
         */
        UPLINK,
        /**
         * Downlink PDRs match on packets travelling in the downlink direction.
         * These packets will not have a GTP tunnel.
         */
        DOWNLINK,
        /**
         * For uplink PDRs that were not build with any action parameters, only match keys.
         * These are usually built in the context of P4Runtime DELETE write requests.
         */
        UPLINK_KEYS_ONLY,
        /**
         * For downlink PDRs that were not build with any action parameters, only match keys.
         * These are usually built in the context of P4Runtime DELETE write requests.
         */
        DOWNLINK_KEYS_ONLY
    }

    public static class Builder {
        private ImmutableByteSequence sessionId = null;
        private Integer ctrId = null;
        private Integer localFarId = null;
        private Integer globalFarId = null;
        private Ip4Address ueAddr = null;
        private ImmutableByteSequence teid = null;
        private Ip4Address tunnelDst = null;

        public Builder() {
        }

        /**
         * Set the ID of the PFCP session that produced this PDR.
         *
         * @param sessionId PFCP session ID
         * @return This builder object
         */
        public Builder withSessionId(ImmutableByteSequence sessionId) {
            this.sessionId = sessionId;
            return this;
        }

        /**
         * Set the ID of the PFCP session that produced this PDR.
         *
         * @param sessionId PFCP session ID
         * @return This builder object
         */
        public Builder withSessionId(long sessionId) {
            try {
                this.sessionId = ImmutableByteSequence.copyFrom(sessionId).fit(SESSION_ID_BITWIDTH);
            } catch (ImmutableByteSequence.ByteSequenceTrimException e) {
                // This error is literally impossible
            }
            return this;
        }

        /**
         * Set the UE IP address that this PDR matches on.
         *
         * @param ueAddr UE IP address
         * @return This builder object
         */
        public Builder withUeAddr(Ip4Address ueAddr) {
            this.ueAddr = ueAddr;
            return this;
        }

        /**
         * Set the dataplane PDR counter cell ID that this PDR is assigned.
         *
         * @param ctrId PDR counter cell ID
         * @return This builder object
         */
        public Builder withCounterId(int ctrId) {
            this.ctrId = ctrId;
            return this;
        }

        /**
         * Set the globally unique ID of the far that should apply to packets that this PDR matches.
         *
         * @param globalFarId globally unique FAR ID
         * @return This builder object
         */
        public Builder withGlobalFarId(int globalFarId) {
            this.globalFarId = globalFarId;
            return this;
        }

        /**
         * Set the PFCP session-local ID of the far that should apply to packets that this PDR matches.
         *
         * @param localFarId PFCP session-local FAR ID
         * @return This builder object
         */
        public Builder withLocalFarId(int localFarId) {
            this.localFarId = localFarId;
            return this;
        }

        /**
         * Set the identifier of the GTP tunnel that this PDR matches on.
         *
         * @param teid GTP tunnel ID
         * @return This builder object
         */
        public Builder withTeid(int teid) {
            this.teid = ImmutableByteSequence.copyFrom(teid);
            return this;
        }

        /**
         * Set the identifier of the GTP tunnel that this PDR matches on.
         *
         * @param teid GTP tunnel ID
         * @return This builder object
         */
        public Builder withTeid(ImmutableByteSequence teid) {
            this.teid = teid;
            return this;
        }

        /**
         * Set the destination IP of the GTP tunnel that this PDR matches on.
         *
         * @param tunnelDst GTP tunnel destination IP
         * @return This builder object
         */
        public Builder withTunnelDst(Ip4Address tunnelDst) {
            this.tunnelDst = tunnelDst;
            return this;
        }

        /**
         * Set the tunnel ID and destination IP of the GTP tunnel that this PDR matches on.
         *
         * @param teid      GTP tunnel ID
         * @param tunnelDst GTP tunnel destination IP
         * @return This builder object
         */
        public Builder withTunnel(ImmutableByteSequence teid, Ip4Address tunnelDst) {
            this.teid = teid;
            this.tunnelDst = tunnelDst;
            return this;
        }

        public PacketDetectionRule build() {
            // Some match keys are required.
            checkArgument((ueAddr != null && teid == null && tunnelDst == null) ||
                            (ueAddr == null && teid != null && tunnelDst != null),
                    "Either a UE address or a TEID and Tunnel destination must be provided, but not both.");
            // Action parameters are optional but must be all provided together if they are provided
            checkArgument((sessionId != null && ctrId != null && localFarId != null) ||
                            (sessionId == null && ctrId == null && localFarId == null),
                    "PDR action parameters must be provided together or not at all.");
            Type type;
            if (teid != null) {
                if (sessionId != null) {
                    type = Type.UPLINK;
                } else {
                    type = Type.UPLINK_KEYS_ONLY;
                }
            } else {
                if (sessionId != null) {
                    type = Type.DOWNLINK;
                } else {
                    type = Type.DOWNLINK_KEYS_ONLY;
                }
            }
            return new PacketDetectionRule(sessionId, ctrId, localFarId, ueAddr, teid, tunnelDst, globalFarId, type);
        }
    }
}
