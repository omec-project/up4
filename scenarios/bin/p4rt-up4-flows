#!/usr/bin/env python3
# SPDX-FileCopyrightText: 2020 Open Networking Foundation <info@opennetworking.org>
# SPDX-License-Identifier: LicenseRef-ONF-Member-1.0
import sys

sys.path.append('/p4runtime-sh/')

import p4runtime_sh.shell as sh
import struct
import argparse
from ipaddress import IPv4Network, IPv4Address

FALSE = '0'
TRUE = '1'
DIR_UPLINK = '1'
DIR_DOWNLINK = '2'
IFACE_ACCESS = '1'
IFACE_CORE = '2'
TUNNEL_SPORT = '2152'
TUNNEL_TYPE_GPDU = '3'

SLICE_MOBILE = "15"
TRAFFIC_CLASS = "1"


def get_args():
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument(
        "--add-ifaces", action='store_true',
        help="If this argument is present, interface table entries will be installed.")
    parser.add_argument(
        "--buffer", action='store_true',
        help="If this argument is present, downlink fars will have" +
        " the buffering flag set to true")
    parser.add_argument("--ue-count", type=int, default=1,
                        help="The number of UE flows for which table entries should be created.")
    parser.add_argument("--ue-pool", type=IPv4Network, default=IPv4Network("17.0.0.0/24"),
                        help="The IPv4 prefix from which UE addresses will be drawn.")
    parser.add_argument("--s1u-addr", type=IPv4Address, default=IPv4Address("140.0.0.1"),
                        help="The IPv4 address of the UPF's S1U interface")
    parser.add_argument("--enb-addr", type=IPv4Address, default=IPv4Address("140.0.100.1"),
                        help="The IPv4 address of the eNodeB")
    parser.add_argument(
        "--teid-base", type=int, default=255, help="The first TEID to use for the first UE. " +
        "Further TEIDs will be generated by incrementing.")
    parser.add_argument("--session-id", type=int, default=1,
                        help="The ID of the PFCP session that is creating these PDRs and FARs")
    parser.add_argument(
        "--pdr-base", type=int, default=1, help="The first PDR ID to use for the first UE. " +
        "Further PDR IDs will be generated by incrementing.")
    parser.add_argument(
        "--far-base", type=int, default=1, help="The first FAR ID to use for the first UE. " +
        "Further FAR IDs will be generated by incrementing.")
    parser.add_argument("--qfi", type=int, default=None, help="The QoS Flow ID. ")
    parser.add_argument(
        "--ctr-base", type=int, default=1,
        help="The first PDR counter index to use for the first UE. " +
        "Further counter indices will be generated by incrementing.")
    parser.add_argument("--election-id", type=int, default=100, help="Election ID")
    parser.add_argument(
        "--base", type=int, default=None, help="First ID used to generate all other ID fields." +
        "If specified, overrides all the other --*-base arguments")
    parser.add_argument("--server", type=str, default="onos1:51001",
                        help="Address and port of the p4runtime server.")
    parser.add_argument("action", choices=["program", "clear", "dry"])
    return parser.parse_args()


args = get_args()


def get_addresses_from_prefix(prefix: IPv4Network, count: int):
    # Currently this doesn't allow the address with host bits all 0,
    #  so the first host address is (prefix_addr & mask) + 1
    if count >= 2**(prefix.max_prefixlen - prefix.prefixlen):
        raise Exception("trying to generate more addresses than a prefix contains!")
    base_addr = ip2int(prefix.network_address) + 1
    offset = 0
    while offset < count:
        yield IPv4Address(base_addr + offset)
        offset += 1


def ip2int(addr: IPv4Address):
    return struct.unpack("!I", addr.packed)[0]


def int2ip(addr: int):
    return IPv4Address(addr)


entries = []


def add_entry(entry, action):
    if action == "program":
        try:
            entry.insert()
            print("*** Entry added.")
        except Exception as e:
            print("Except during table insertion:", e)
            print("Entry was:", entry)
            print("%d entries were successfully added before failure" % len(entries))
            clear_entries()
            sys.exit(1)
    entries.append(entry)


def clear_entries():
    for i, entry in enumerate(entries):
        entry.delete()
        print("*** Entry %d of %d deleted." % (i + 1, len(entries)))


def main():
    # Connect to gRPC server
    sh.setup(
        device_id=1,
        grpc_addr=args.server,
        election_id=(0, args.election_id),  # (high, low)
    )

    # ========================#
    # Interface Entries
    #  Filter entries are now installed when the netconfig is loaded,
    #  and do not need to be installed via P4RT.
    # ========================#
    if args.add_ifaces:
        # Uplink
        entry = sh.TableEntry('PreQosPipe.interfaces')(
            action='PreQosPipe.set_source_iface')
        entry.match['ipv4_dst_prefix'] = str(args.s1u_addr) + '/32'
        entry.action['src_iface'] = IFACE_ACCESS
        entry.action['direction'] = DIR_UPLINK
        add_entry(entry, args.action)

        # Downlink
        entry = sh.TableEntry('PreQosPipe.interfaces')(
            action='PreQosPipe.set_source_iface')
        entry.match['ipv4_dst_prefix'] = str(args.ue_pool)
        entry.action['src_iface'] = IFACE_CORE
        entry.action['direction'] = DIR_DOWNLINK
        add_entry(entry, args.action)

    # table entry parameter generators
    rule_count = args.ue_count * 2
    ue_addr_gen = get_addresses_from_prefix(args.ue_pool, args.ue_count)
    teid_gen = iter(
        range(args.base if args.base else args.teid_base,
              (args.base if args.base else args.teid_base) + args.ue_count))
    ctr_id_gen = iter(
        range(args.base if args.base else args.ctr_base,
              (args.base if args.base else args.ctr_base) + rule_count))
    tunnel_peer_gen = iter(
        range(args.base if args.base else args.ctr_base,
              (args.base if args.base else args.ctr_base) + rule_count))

    for ue_index in range(args.ue_count):
        ue_addr = next(ue_addr_gen)
        teid = next(teid_gen)

        ctr_uplink = next(ctr_id_gen)
        ctr_downlink = next(ctr_id_gen)

        tunnel_peer_id = next(tunnel_peer_gen)

        # ========================#
        # UE Session Entries
        # ========================#

        ## Uplink
        entry = sh.TableEntry('PreQosPipe.sessions')(action='PreQosPipe.set_params_uplink')
        # Match fields
        entry.match['src_iface'] = IFACE_ACCESS
        entry.match['ipv4_dst'] = str(args.s1u_addr)
        entry.match['teid'] = str(teid)
        if args.qfi is not None:
            print("QFI match currently unsupported!!")
        add_entry(entry, args.action)

        ## Downlink
        if not args.buffer:
            entry = sh.TableEntry('PreQosPipe.sessions')(action='PreQosPipe.set_params_downlink')
            entry.action["tunnel_peer_id"] = str(tunnel_peer_id)
        else:
            entry = sh.TableEntry('PreQosPipe.sessions')(action='PreQosPipe.set_params_buffering')
        # Match fields
        entry.match['src_iface'] = IFACE_CORE
        entry.match['ipv4_dst'] = str(ue_addr)
        add_entry(entry, args.action)

        # ========================#
        # Terminations Entries
        # ========================#

        ## Uplink
        entry = sh.TableEntry('PreQosPipe.terminations')(
            action='PreQosPipe.term_uplink')
        # Match fields
        entry.match['src_iface'] = IFACE_ACCESS
        entry.match['ue_address'] = str(ue_addr)
        # Action params
        entry.action['ctr_idx'] = str(ctr_uplink)
        entry.action['tc'] = TRAFFIC_CLASS
        add_entry(entry, args.action)

        ## Downlink
        entry = sh.TableEntry('PreQosPipe.terminations')(
            action='PreQosPipe.term_downlink')
        # Match fields
        entry.match['src_iface'] = IFACE_CORE
        entry.match['ue_address'] = str(ue_addr)
        # Action params
        entry.action['teid'] = str(teid)
        entry.action['ctr_idx'] = str(ctr_downlink)
        entry.action['tc'] = TRAFFIC_CLASS
        entry.action['qfi'] = str(args.qfi) if args.qfi else "0"
        add_entry(entry, args.action)

        # ========================#
        # Tunnel Peer Entry
        # ========================#
        entry = sh.TableEntry('PreQosPipe.tunnel_peers')(
            action='PreQosPipe.load_tunnel_param')
        # Match fields
        entry.match['tunnel_peer_id'] = str(tunnel_peer_id)
        # Action params
        entry.action['src_addr'] = str(args.s1u_addr)
        entry.action['dst_addr'] = str(args.enb_addr)
        entry.action['sport'] = TUNNEL_SPORT
        add_entry(entry, args.action)

    if args.action == "program":
        print("All entries added sucessfully.")

    elif args.action == "clear":
        clear_entries()

    elif args.action == "dry":
        for entry in entries:
            print(entry)

    sh.teardown()


if __name__ == "__main__":
    main()
