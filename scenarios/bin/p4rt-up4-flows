#!/usr/bin/env python3
# SPDX-FileCopyrightText: 2020 Open Networking Foundation <info@opennetworking.org>
# SPDX-License-Identifier: LicenseRef-ONF-Member-1.0
import sys

sys.path.append('/p4runtime-sh/')

import p4runtime_sh.shell as sh
import struct
import argparse
from ipaddress import IPv4Network, IPv4Address

FALSE = '0'
TRUE = '1'
DIR_UPLINK = '1'
DIR_DOWNLINK = '2'
IFACE_ACCESS = '1'
IFACE_CORE = '2'
TUNNEL_SPORT = '2152'
TUNNEL_TYPE_GPDU = '3'

SLICE_MOBILE = "15"
TRAFFIC_CLASS = "1"

DEFAULT_APP_ID = 0


def get_args():
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument(
        "--add-ifaces", action='store_true',
        help="If this argument is present, interface table entries will be installed.")
    parser.add_argument("--buffer", action='store_true',
                        help="If this argument is present, downlink session will buffer traffic")
    parser.add_argument("--ue-count", type=int, default=1,
                        help="The number of UE flows for which table entries should be created.")
    parser.add_argument("--ue-pool", type=IPv4Network, default=IPv4Network("17.0.0.0/24"),
                        help="The IPv4 prefix from which UE addresses will be drawn.")
    parser.add_argument("--s1u-addr", type=IPv4Address, default=IPv4Address("140.0.0.1"),
                        help="The IPv4 address of the UPF's S1U interface")
    parser.add_argument("--enb-addr", type=IPv4Address, default=IPv4Address("140.0.100.1"),
                        help="The IPv4 address of the eNodeB")
    parser.add_argument(
        "--teid-base", type=int, default=255, help="The first TEID to use for the first UE. " +
        "Further TEIDs will be generated by incrementing.")
    parser.add_argument("--qfi", type=int, default=None, help="The QoS Flow ID. ")
    parser.add_argument(
        "--ctr-base", type=int, default=None,
        help="The first UPF counter index to use for the first UE. " +
        "Further counter indices will be generated by incrementing.")
    parser.add_argument("--election-id", type=int, default=100, help="Election ID")
    parser.add_argument(
        "--base", type=int, default=None, help="First ID used to generate all other ID fields." +
        "If specified, overrides all the other --*-base arguments")
    parser.add_argument("--prio-app-filter", type=int, default=1,
                        help="Priority of the application filtering rule")
    parser.add_argument("--app-id", type=int, default=DEFAULT_APP_ID,
                        help="Application ID. ID=0 means NO application filtering.")
    parser.add_argument("--ipv4-app-filter", type=str, default=None,
                        help="IPv4 prefix for application filtering")
    parser.add_argument("--l4-app-filter", type=int, default=None,
                        help="L4 Port for application filtering")
    parser.add_argument("--proto-app-filter", choices=['UDP', 'TCP', 'ICMP'], default=None,
                        help="IP Proto value for application filtering")
    parser.add_argument("--ul-drop", type=bool, default=False,
                        help="Drop traffic in uplink direction")
    parser.add_argument("--dl-drop", type=bool, default=False,
                        help="Drop traffic in downlink direction")

    parser.add_argument("--server", type=str, default="onos1:51001",
                        help="Address and port of the p4runtime server.")
    parser.add_argument("action", choices=["program", "clear", "dry"])
    return parser.parse_args()


args = get_args()


def get_addresses_from_prefix(prefix: IPv4Network, count: int):
    # Currently this doesn't allow the address with host bits all 0,
    #  so the first host address is (prefix_addr & mask) + 1
    if count >= 2**(prefix.max_prefixlen - prefix.prefixlen):
        raise Exception("trying to generate more addresses than a prefix contains!")
    base_addr = ip2int(prefix.network_address) + 1
    offset = 0
    while offset < count:
        yield IPv4Address(base_addr + offset)
        offset += 1


def ip2int(addr: IPv4Address):
    return struct.unpack("!I", addr.packed)[0]


def int2ip(addr: int):
    return IPv4Address(addr)


entries = []


def add_entry(entry, action):
    if action == "program":
        try:
            entry.insert()
            print("*** Entry added.")
        except Exception as e:
            print("Except during table insertion:", e)
            print("Entry was:", entry)
            print("%d entries were successfully added before failure" % len(entries))
            clear_entries()
            sys.exit(1)
    entries.append(entry)


def clear_entries():
    for i, entry in enumerate(entries):
        entry.delete()
        print("*** Entry %d of %d deleted." % (i + 1, len(entries)))


def main():
    # Validate some args
    app_filtering = False
    if args.ipv4_app_filter or args.l4_app_filter or args.proto_app_filter:
        app_filtering = True
        if args.base == 0 or (not args.base and args.app_id == 0):
            print("APP ID must be different from 0, when doing application filtering")
            exit(1)
    if not args.ctr_base and not args.base:
        print('Either "ctr-base" or "base" arguments must be provided')
        exit(1)

    # Connect to gRPC server
    sh.setup(
        device_id=1,
        grpc_addr=args.server,
        election_id=(0, args.election_id),  # (high, low)
    )

    # ========================#
    # Interface Entries
    #  Filter entries are now installed when the netconfig is loaded,
    #  and do not need to be installed via P4RT.
    # ========================#
    if args.add_ifaces:
        # Uplink
        entry = sh.TableEntry('PreQosPipe.interfaces')(action='PreQosPipe.set_source_iface')
        entry.match['ipv4_dst_prefix'] = str(args.s1u_addr) + '/32'
        entry.action['src_iface'] = IFACE_ACCESS
        entry.action['direction'] = DIR_UPLINK
        add_entry(entry, args.action)

        # Downlink
        entry = sh.TableEntry('PreQosPipe.interfaces')(action='PreQosPipe.set_source_iface')
        entry.match['ipv4_dst_prefix'] = str(args.ue_pool)
        entry.action['src_iface'] = IFACE_CORE
        entry.action['direction'] = DIR_DOWNLINK
        add_entry(entry, args.action)

    # table entry parameter generators
    rule_count = args.ue_count * 2
    ue_addr_gen = get_addresses_from_prefix(args.ue_pool, args.ue_count)
    teid_gen = iter(
        range(args.base if args.base else args.teid_base,
              (args.base if args.base else args.teid_base) + args.ue_count))
    ctr_id_gen = iter(
        range(args.ctr_base if args.ctr_base is not None else args.base,
              (args.ctr_base if args.ctr_base is not None else args.base) + rule_count))
    tunnel_peer_gen = iter(
        range(args.base if args.base else args.ctr_base,
              (args.base if args.base else args.ctr_base) + rule_count))
    app_id = args.app_id

    if app_filtering:
        entry = sh.TableEntry('PreQosPipe.applications')(action='PreQosPipe.set_app_id')
        if args.ipv4_app_filter:
            entry.match["app_ip_addr"] = args.ipv4_app_filter
        if args.l4_app_filter:
            entry.match["app_l4_port"] = str(args.l4_app_filter) + ".." + str(args.l4_app_filter)
        if args.proto_app_filter:
            entry.match["app_ip_proto"] = args.proto_app_filter
        entry.action["app_id"] = str(app_id)
        entry.priority = args.prio_app_filter
        add_entry(entry, args.action)

    for ue_index in range(args.ue_count):
        ue_addr = next(ue_addr_gen)
        teid = next(teid_gen)

        ctr_uplink = next(ctr_id_gen)
        ctr_downlink = next(ctr_id_gen)

        tunnel_peer_id = next(tunnel_peer_gen)

        # ========================#
        # UE Session Entries
        # ========================#

        ## Uplink
        entry = sh.TableEntry('PreQosPipe.sessions_uplink')(action='PreQosPipe.set_session_uplink')
        # Match fields
        entry.match['n3_address'] = str(args.s1u_addr)
        entry.match['teid'] = str(teid)
        if args.qfi is not None:
            print("QFI match currently unsupported!!")
        add_entry(entry, args.action)

        ## Downlink
        if not args.buffer:
            entry = sh.TableEntry('PreQosPipe.sessions_downlink')(
                action='PreQosPipe.set_session_downlink')
            entry.action["tunnel_peer_id"] = str(tunnel_peer_id)
        else:
            entry = sh.TableEntry('PreQosPipe.sessions_downlink')(
                action='PreQosPipe.set_session_downlink_buff')
        # Match fields
        entry.match['ue_address'] = str(ue_addr)
        add_entry(entry, args.action)

        # ========================#
        # Terminations Entries
        # ========================#

        ## Uplink
        if not args.ul_drop:
            entry = sh.TableEntry('PreQosPipe.terminations_uplink')(
                action='PreQosPipe.uplink_term_fwd')
            entry.action['tc'] = TRAFFIC_CLASS
        else:
            entry = sh.TableEntry('PreQosPipe.terminations_uplink')(
                action='PreQosPipe.uplink_term_drop')
        entry.match['ue_address'] = str(ue_addr)
        entry.match["app_id"] = str(app_id)
        entry.action['ctr_idx'] = str(ctr_uplink)
        add_entry(entry, args.action)

        ## Downlink
        if not args.dl_drop:
            entry = sh.TableEntry('PreQosPipe.terminations_downlink')(
                action='PreQosPipe.downlink_term_fwd')
            entry.action['tc'] = TRAFFIC_CLASS
            entry.action['qfi'] = str(args.qfi) if args.qfi else "0"
            entry.action['teid'] = str(teid)
        else:
            entry = sh.TableEntry('PreQosPipe.terminations_downlink')(
                action='PreQosPipe.downlink_term_drop')
        entry.match['ue_address'] = str(ue_addr)
        entry.match["app_id"] = str(app_id)
        entry.action['ctr_idx'] = str(ctr_downlink)
        add_entry(entry, args.action)

        # ========================#
        # Tunnel Peer Entry
        # ========================#
        entry = sh.TableEntry('PreQosPipe.tunnel_peers')(action='PreQosPipe.load_tunnel_param')
        # Match fields
        entry.match['tunnel_peer_id'] = str(tunnel_peer_id)
        # Action params
        entry.action['src_addr'] = str(args.s1u_addr)
        entry.action['dst_addr'] = str(args.enb_addr)
        entry.action['sport'] = TUNNEL_SPORT
        add_entry(entry, args.action)

    if args.action == "program":
        print("All entries added sucessfully.")

    elif args.action == "clear":
        clear_entries()

    elif args.action == "dry":
        for entry in entries:
            print(entry)

    sh.teardown()


if __name__ == "__main__":
    main()
